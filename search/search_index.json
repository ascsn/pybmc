{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pybmc Documentation Bayesian model combination Statistical inference Ensemble modeling Simple Python API Introduction pybmc is a Python package that implements a Bayesian model combination strategy with the following features: Versatile : Works with any set of models on a given domain Flexible : Handles vector inputs and predictions Powerful : Includes optional orthogonalization steps Complete : Training, validation, and testing functions built-in Why Bayesian Model Combination? Bayesian model combination (BMC) provides a principled approach to combining predictions from multiple models. Unlike simple averaging or voting techniques, BMC: Accounts for correlations between models Assigns optimal weights based on model performance Provides uncertainty estimates for predictions Is robust against overfitting # Quick example from pybmc import BayesianModelCombination , Model # Create models model1 = Model ( \"linear\" , predictions_train , targets_train ) model2 = Model ( \"neural\" , predictions_train , targets_train ) # Set up BMC bmc = BayesianModelCombination ([ model1 , model2 ]) bmc . train () # Get combined predictions predictions = bmc . predict ( new_data ) Installation Install the package using pip: pip install pybmc Or using poetry: poetry add pybmc Features Feature Description Multiple models Combine any number of pre-trained models Custom domains Works with any input domain X (can be a vector) Vector predictions Y(X) can be a vector itself (e.g., masses, radii) Orthogonalization Optional step to improve model combination Flexible datasets Training, validation, and testing with partial data Usage Example import numpy as np from pybmc.models import Model from pybmc.data import Dataset from pybmc.bmc import BayesianModelCombination # Create models model1 = Model ( \"model1\" , np . array ([ 1 , 2 , 3 ]), np . array ([ 10 , 20 , 30 ])) model2 = Model ( \"model2\" , np . array ([ 1 , 2 , 3 ]), np . array ([ 15 , 25 , 35 ])) # Load data data_source = \"path/to/data_source\" dataset = Dataset ( data_source ) data = dataset . load_data ( data_source ) # Split data train_data , val_data , test_data = dataset . split_data ( train_size = 0.6 , val_size = 0.2 , test_size = 0.2 ) # Create Bayesian model combination bmc = BayesianModelCombination ( models = [ model1 , model2 ], options = { 'use_orthogonalization' : True }) # Orthogonalize models (optional) bmc . orthogonalize ( train_data ) # Train the model combination bmc . train ( train_data ) # Predict using the model combination X = np . array ([ 1 , 2 , 3 ]) predictions = bmc . predict ( X ) # Evaluate the model combination evaluation = bmc . evaluate ( val_data ) Getting Started Check out the Usage page for more detailed examples and the API Reference for complete documentation.","title":"Home"},{"location":"#welcome-to-pybmc-documentation","text":"Bayesian model combination Statistical inference Ensemble modeling Simple Python API","title":"Welcome to pybmc Documentation"},{"location":"#introduction","text":"pybmc is a Python package that implements a Bayesian model combination strategy with the following features: Versatile : Works with any set of models on a given domain Flexible : Handles vector inputs and predictions Powerful : Includes optional orthogonalization steps Complete : Training, validation, and testing functions built-in","title":"Introduction"},{"location":"#why-bayesian-model-combination","text":"Bayesian model combination (BMC) provides a principled approach to combining predictions from multiple models. Unlike simple averaging or voting techniques, BMC: Accounts for correlations between models Assigns optimal weights based on model performance Provides uncertainty estimates for predictions Is robust against overfitting # Quick example from pybmc import BayesianModelCombination , Model # Create models model1 = Model ( \"linear\" , predictions_train , targets_train ) model2 = Model ( \"neural\" , predictions_train , targets_train ) # Set up BMC bmc = BayesianModelCombination ([ model1 , model2 ]) bmc . train () # Get combined predictions predictions = bmc . predict ( new_data )","title":"Why Bayesian Model Combination?"},{"location":"#installation","text":"Install the package using pip: pip install pybmc Or using poetry: poetry add pybmc","title":"Installation"},{"location":"#features","text":"Feature Description Multiple models Combine any number of pre-trained models Custom domains Works with any input domain X (can be a vector) Vector predictions Y(X) can be a vector itself (e.g., masses, radii) Orthogonalization Optional step to improve model combination Flexible datasets Training, validation, and testing with partial data","title":"Features"},{"location":"#usage-example","text":"import numpy as np from pybmc.models import Model from pybmc.data import Dataset from pybmc.bmc import BayesianModelCombination # Create models model1 = Model ( \"model1\" , np . array ([ 1 , 2 , 3 ]), np . array ([ 10 , 20 , 30 ])) model2 = Model ( \"model2\" , np . array ([ 1 , 2 , 3 ]), np . array ([ 15 , 25 , 35 ])) # Load data data_source = \"path/to/data_source\" dataset = Dataset ( data_source ) data = dataset . load_data ( data_source ) # Split data train_data , val_data , test_data = dataset . split_data ( train_size = 0.6 , val_size = 0.2 , test_size = 0.2 ) # Create Bayesian model combination bmc = BayesianModelCombination ( models = [ model1 , model2 ], options = { 'use_orthogonalization' : True }) # Orthogonalize models (optional) bmc . orthogonalize ( train_data ) # Train the model combination bmc . train ( train_data ) # Predict using the model combination X = np . array ([ 1 , 2 , 3 ]) predictions = bmc . predict ( X ) # Evaluate the model combination evaluation = bmc . evaluate ( val_data ) Getting Started Check out the Usage page for more detailed examples and the API Reference for complete documentation.","title":"Usage Example"},{"location":"api_reference/","text":"API Reference Model Class Model A class representing a model with a domain (x) and an output (y). Attributes name (str): The name of the model. x (np.ndarray): The domain of the model. y (np.ndarray): The output of the model. Methods __init__(self, name, x, y) : Initialize the Model object. Args: name (str): The name of the model. x (array-like): The domain of the model. y (array-like): The output of the model. Dataset Class Dataset A class representing a dataset. Attributes data (any): The data of the dataset. Methods __init__(self, data) : Initialize the Dataset object. Args: data (any): The data of the dataset. load_data(self, source) : Load data from a given source. Args: source (str): The source of the data. split_data(self, train_size, val_size, test_size) : Split data into training, validation, and testing sets. Args: train_size (float): The proportion of the data to include in the training set. val_size (float): The proportion of the data to include in the validation set. test_size (float): The proportion of the data to include in the testing set. get_subset(self, domain_X) : Return a subset of data for a given domain X. Args: domain_X (any): The domain for which to return the subset of data. BayesianModelCombination Class BayesianModelCombination A class representing a Bayesian model combination. Attributes models (list or np.ndarray): The list or array of models. options (dict): The options for the model combination. weights (any): The weights of the models. Methods __init__(self, models, options=None) : Initialize the BayesianModelCombination object. Args: models (list or np.ndarray): The list or array of models. options (dict, optional): The options for the model combination. Defaults to None. train(self, training_data) : Train the model combination using training data. Args: training_data (any): The training data. predict(self, X) : Produce predictions using the learned model weights. Args: X (any): The input data. evaluate(self, data) : Evaluate the model combination on validation or testing data. Args: data (any): The data to evaluate the model combination on. orthogonalize(self, data) : Orthogonalize the models using the given data. Args: data (any): The data to use for orthogonalization.","title":"API Reference"},{"location":"api_reference/#api-reference","text":"","title":"API Reference"},{"location":"api_reference/#model-class","text":"","title":"Model Class"},{"location":"api_reference/#model","text":"A class representing a model with a domain (x) and an output (y).","title":"Model"},{"location":"api_reference/#attributes","text":"name (str): The name of the model. x (np.ndarray): The domain of the model. y (np.ndarray): The output of the model.","title":"Attributes"},{"location":"api_reference/#methods","text":"__init__(self, name, x, y) : Initialize the Model object. Args: name (str): The name of the model. x (array-like): The domain of the model. y (array-like): The output of the model.","title":"Methods"},{"location":"api_reference/#dataset-class","text":"","title":"Dataset Class"},{"location":"api_reference/#dataset","text":"A class representing a dataset.","title":"Dataset"},{"location":"api_reference/#attributes_1","text":"data (any): The data of the dataset.","title":"Attributes"},{"location":"api_reference/#methods_1","text":"__init__(self, data) : Initialize the Dataset object. Args: data (any): The data of the dataset. load_data(self, source) : Load data from a given source. Args: source (str): The source of the data. split_data(self, train_size, val_size, test_size) : Split data into training, validation, and testing sets. Args: train_size (float): The proportion of the data to include in the training set. val_size (float): The proportion of the data to include in the validation set. test_size (float): The proportion of the data to include in the testing set. get_subset(self, domain_X) : Return a subset of data for a given domain X. Args: domain_X (any): The domain for which to return the subset of data.","title":"Methods"},{"location":"api_reference/#bayesianmodelcombination-class","text":"","title":"BayesianModelCombination Class"},{"location":"api_reference/#bayesianmodelcombination","text":"A class representing a Bayesian model combination.","title":"BayesianModelCombination"},{"location":"api_reference/#attributes_2","text":"models (list or np.ndarray): The list or array of models. options (dict): The options for the model combination. weights (any): The weights of the models.","title":"Attributes"},{"location":"api_reference/#methods_2","text":"__init__(self, models, options=None) : Initialize the BayesianModelCombination object. Args: models (list or np.ndarray): The list or array of models. options (dict, optional): The options for the model combination. Defaults to None. train(self, training_data) : Train the model combination using training data. Args: training_data (any): The training data. predict(self, X) : Produce predictions using the learned model weights. Args: X (any): The input data. evaluate(self, data) : Evaluate the model combination on validation or testing data. Args: data (any): The data to evaluate the model combination on. orthogonalize(self, data) : Orthogonalize the models using the given data. Args: data (any): The data to use for orthogonalization.","title":"Methods"},{"location":"usage/","text":"Usage Here is an example of how to use the package: import numpy as np from pybmc.models import Model from pybmc.data import Dataset from pybmc.bmc import BayesianModelCombination # Create models model1 = Model ( \"model1\" , np . array ([ 1 , 2 , 3 ]), np . array ([ 10 , 20 , 30 ])) model2 = Model ( \"model2\" , np . array ([ 1 , 2 , 3 ]), np . array ([ 15 , 25 , 35 ])) # Load data data_source = \"path/to/data_source\" dataset = Dataset ( data_source ) data = dataset . load_data ( data_source ) # Split data train_data , val_data , test_data = dataset . split_data ( train_size = 0.6 , val_size = 0.2 , test_size = 0.2 ) # Create Bayesian model combination bmc = BayesianModelCombination ( models = [ model1 , model2 ], options = { 'use_orthogonalization' : True }) # Orthogonalize models (optional) bmc . orthogonalize ( train_data ) # Train the model combination bmc . train ( train_data ) # Predict using the model combination X = np . array ([ 1 , 2 , 3 ]) predictions = bmc . predict ( X ) # Evaluate the model combination evaluation = bmc . evaluate ( val_data ) Explanation of Each Step Create models : We create two instances of the Model class, model1 and model2 , with their respective domains and outputs. Load data : We create an instance of the Dataset class and load data from a specified source. Split data : We split the loaded data into training, validation, and testing sets. Create Bayesian model combination : We create an instance of the BayesianModelCombination class with the created models and an option to use orthogonalization. Orthogonalize models (optional) : We orthogonalize the models using the training data if the orthogonalization option is enabled. Train the model combination : We train the Bayesian model combination using the training data. Predict using the model combination : We use the trained model combination to make predictions for a given input. Evaluate the model combination : We evaluate the performance of the model combination using the validation data.","title":"Usage"},{"location":"usage/#usage","text":"Here is an example of how to use the package: import numpy as np from pybmc.models import Model from pybmc.data import Dataset from pybmc.bmc import BayesianModelCombination # Create models model1 = Model ( \"model1\" , np . array ([ 1 , 2 , 3 ]), np . array ([ 10 , 20 , 30 ])) model2 = Model ( \"model2\" , np . array ([ 1 , 2 , 3 ]), np . array ([ 15 , 25 , 35 ])) # Load data data_source = \"path/to/data_source\" dataset = Dataset ( data_source ) data = dataset . load_data ( data_source ) # Split data train_data , val_data , test_data = dataset . split_data ( train_size = 0.6 , val_size = 0.2 , test_size = 0.2 ) # Create Bayesian model combination bmc = BayesianModelCombination ( models = [ model1 , model2 ], options = { 'use_orthogonalization' : True }) # Orthogonalize models (optional) bmc . orthogonalize ( train_data ) # Train the model combination bmc . train ( train_data ) # Predict using the model combination X = np . array ([ 1 , 2 , 3 ]) predictions = bmc . predict ( X ) # Evaluate the model combination evaluation = bmc . evaluate ( val_data )","title":"Usage"},{"location":"usage/#explanation-of-each-step","text":"Create models : We create two instances of the Model class, model1 and model2 , with their respective domains and outputs. Load data : We create an instance of the Dataset class and load data from a specified source. Split data : We split the loaded data into training, validation, and testing sets. Create Bayesian model combination : We create an instance of the BayesianModelCombination class with the created models and an option to use orthogonalization. Orthogonalize models (optional) : We orthogonalize the models using the training data if the orthogonalization option is enabled. Train the model combination : We train the Bayesian model combination using the training data. Predict using the model combination : We use the trained model combination to make predictions for a given input. Evaluate the model combination : We evaluate the performance of the model combination using the validation data.","title":"Explanation of Each Step"}]}